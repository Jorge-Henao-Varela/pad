# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a7LsaWzG1qeD5wOQa0Pbv5yXRnyIluB_
"""

import numpy as np
import matplotlib.pyplot as plt

# IntroducciÃ³n y cÃ¡lculos con los arrays de NumPy
# 1. Genera un array de NumPy con valores desde 10 hasta 29.
array_1 = np.arange(10, 30)
print("Array 1:", array_1)

# 2. Calcula la suma de todos los elementos en un array de NumPy de tamaÃ±o 10x10, lleno de unos.
array_2 = np.ones((10, 10))
suma_array_2 = np.sum(array_2)
print("Suma del array 2:", suma_array_2)

# 3. Dados dos arrays de tamaÃ±o 5, llenos de nÃºmeros aleatorios desde 1 hasta 10, realiza un producto elemento a elemento.
array_3_1 = np.random.randint(1, 11, 5)
array_3_2 = np.random.randint(1, 11, 5)
producto_elemento_a_elemento = array_3_1 * array_3_2
print("Producto elemento a elemento:", producto_elemento_a_elemento)

# 4. Crea una matriz de 4x4, donde cada elemento es igual a i+j (con i y j siendo el Ã­ndice de fila y columna, respectivamente) y calcula su inversa.
matriz_4 = np.array([[i+j for j in range(4)] for i in range(4)])
inversa_matriz_4 = np.linalg.inv(matriz_4)
print("Matriz 4:\n", matriz_4)
print("Inversa de la matriz 4:\n", inversa_matriz_4)

# 5. Encuentra los valores mÃ¡ximo y mÃ­nimo en un array de 100 elementos aleatorios y muestra sus Ã­ndices.
array_5 = np.random.rand(100)
max_valor = np.max(array_5)
min_valor = np.min(array_5)
max_indice = np.argmax(array_5)
min_indice = np.argmin(array_5)
print("Valor mÃ¡ximo:", max_valor, "Ãndice:", max_indice)
print("Valor mÃ­nimo:", min_valor, "Ãndice:", min_indice)

# Broadcasting e indexado de Arrays
# 6. Crea un array de tamaÃ±o 3x1 y uno de 1x3, y sÃºmalos utilizando broadcasting para obtener un array de 3x3.
array_6_1 = np.array([[1], [2], [3]])
array_6_2 = np.array([[4, 5, 6]])
suma_broadcasting = array_6_1 + array_6_2
print("Suma con broadcasting:\n", suma_broadcasting)

# 7. De una matriz 5x5, extrae una submatriz 2x2 que comience en la segunda fila y columna.
matriz_7 = np.random.rand(5, 5)
submatriz_7 = matriz_7[1:3, 1:3]
print("Submatriz 7:\n", submatriz_7)

# 8. Crea un array de ceros de tamaÃ±o 10 y usa indexado para cambiar el valor de los elementos en el rango de Ã­ndices 3 a 6 a 5.
array_8 = np.zeros(10)
array_8[3:7] = 5
print("Array 8:", array_8)

# 9. Dada una matriz de 3x3, invierte el orden de sus filas.
matriz_9 = np.random.rand(3, 3)
filas_invertidas = matriz_9[::-1]
print("Matriz 9 con filas invertidas:\n", filas_invertidas)

# 10. Dado un array de nÃºmeros aleatorios de tamaÃ±o 10, selecciona y muestra solo aquellos que sean mayores a 0.5.
array_10 = np.random.rand(10)
mayores_a_05 = array_10[array_10 > 0.5]
print("Valores mayores a 0.5:", mayores_a_05)

# GrÃ¡ficos de dispersiÃ³n, densidad y contorno
# 11. Genera dos arrays de tamaÃ±o 100 con nÃºmeros aleatorios y crea un grÃ¡fico de dispersiÃ³n.
array_11_x = np.random.rand(100)
array_11_y = np.random.rand(100)
plt.scatter(array_11_x, array_11_y)
plt.title("GrÃ¡fico de dispersiÃ³n")
plt.show()

# 12. Genera un grÃ¡fico de dispersiÃ³n las variables ğ‘¥ y ğ‘¦ = ğ‘ ğ‘–ğ‘›(ğ‘¥)+ ruido Gaussiano. Donde x es un array con nÃºmereos entre -2ğœ‹ ğ‘¦ 2ğœ‹. Grafica tambiÃ©n los puntos ğ‘¦ = ğ‘ ğ‘–ğ‘›(ğ‘¥) en el mismo plot
x = np.linspace(-2*np.pi, 2*np.pi, 100)
ruido = np.random.normal(0, 0.5, 100)
y = np.sin(x) + ruido
plt.scatter(x, y, label='sin(x) + ruido')
plt.plot(x, np.sin(x), color='red', label='sin(x)')
plt.title("GrÃ¡fico de dispersiÃ³n con ruido")
plt.xlabel("Eje X")
plt.ylabel("Eje Y")
plt.legend()
plt.show()

# 13. Utiliza la funciÃ³n np.meshgrid para crear una cuadrÃ­cula y luego aplica la funciÃ³n z = np.cos(x) + np.sin(y) para generar y mostrar un grÃ¡fico de contorno.
x = np.linspace(-5, 5, 100)
y = np.linspace(-5, 5, 100)
X, Y = np.meshgrid(x, y)
Z = np.cos(X) + np.sin(Y)
plt.contour(X, Y, Z)
plt.title("GrÃ¡fico de contorno")
plt.show()

# 14. Crea un grÃ¡fico de dispersiÃ³n con 1000 puntos aleatorios y utiliza la densidad de estos puntos para ajustar el color de cada punto.
x = np.random.rand(1000)
y = np.random.rand(1000)
plt.hist2d(x, y, bins=20, cmap='viridis')
plt.colorbar(label='Densidad')
plt.title("GrÃ¡fico de dispersiÃ³n con densidad")
plt.show()

# 15. A partir de la misma funciÃ³n del ejercicio 12, genera un grÃ¡fico de contorno lleno.
x = np.linspace(-2*np.pi, 2*np.pi, 100)
y = np.sin(x)
plt.contourf(x, y)
plt.title("GrÃ¡fico de contorno lleno")
plt.show()

# 16. AÃ±ade etiquetas para el eje X (â€˜Eje Xâ€™), eje Y (â€˜Eje Yâ€™) y un tÃ­tulo (â€˜GrÃ¡fico de DispersiÃ³nâ€™) a tu grÃ¡fico de dispersiÃ³n del ejercicio 12 y crea leyendas para cada grÃ¡fico usando cÃ³digo LaTex
x = np.linspace(-2*np.pi, 2*np.pi, 100)
ruido = np.random.normal(0, 0.5, 100)
y = np.sin(x) + ruido
plt.scatter(x, y, label=r'<span class="math-inline">sin\(x\) \+ ruido</span>')
plt.plot(x, np.sin(x), color='red', label=r'<span class="math-inline">sin\(x\)</span>')
plt.title("GrÃ¡fico de DispersiÃ³n")
plt.xlabel("Eje X")
plt.ylabel("Eje Y")
plt.legend()
plt.show()

# Histogramas
# 16. Crea un histograma a partir de un array de 1000 nÃºmeros aleatorios generados con una distribuciÃ³n normal.
datos_16 = np.random.normal(0, 1, 1000)
plt.hist(datos_16, bins=30)
plt.title("Histograma de distribuciÃ³n normal")
plt.show()

# 17. Genera dos sets de datos con distribuciones normales diferentes y muÃ©stralos en el mismo histograma.
datos_17_1 = np.random.normal(0, 1, 1000)
datos_17_2 = np.random.normal(2, 1.5, 1000)
plt.hist(datos_17_1, bins=30, alpha=0.5, label='DistribuciÃ³n 1')
plt