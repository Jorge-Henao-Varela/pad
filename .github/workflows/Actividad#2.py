# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a7LsaWzG1qeD5wOQa0Pbv5yXRnyIluB_
"""

import numpy as np
import matplotlib.pyplot as plt

# Introducción y cálculos con los arrays de NumPy
# 1. Genera un array de NumPy con valores desde 10 hasta 29.
array_1 = np.arange(10, 30)
print("Array 1:", array_1)

# 2. Calcula la suma de todos los elementos en un array de NumPy de tamaño 10x10, lleno de unos.
array_2 = np.ones((10, 10))
suma_array_2 = np.sum(array_2)
print("Suma del array 2:", suma_array_2)

# 3. Dados dos arrays de tamaño 5, llenos de números aleatorios desde 1 hasta 10, realiza un producto elemento a elemento.
array_3_1 = np.random.randint(1, 11, 5)
array_3_2 = np.random.randint(1, 11, 5)
producto_elemento_a_elemento = array_3_1 * array_3_2
print("Producto elemento a elemento:", producto_elemento_a_elemento)

# 4. Crea una matriz de 4x4, donde cada elemento es igual a i+j (con i y j siendo el índice de fila y columna, respectivamente) y calcula su inversa.
matriz_4 = np.array([[i+j for j in range(4)] for i in range(4)])
inversa_matriz_4 = np.linalg.inv(matriz_4)
print("Matriz 4:\n", matriz_4)
print("Inversa de la matriz 4:\n", inversa_matriz_4)

# 5. Encuentra los valores máximo y mínimo en un array de 100 elementos aleatorios y muestra sus índices.
array_5 = np.random.rand(100)
max_valor = np.max(array_5)
min_valor = np.min(array_5)
max_indice = np.argmax(array_5)
min_indice = np.argmin(array_5)
print("Valor máximo:", max_valor, "Índice:", max_indice)
print("Valor mínimo:", min_valor, "Índice:", min_indice)

# Broadcasting e indexado de Arrays
# 6. Crea un array de tamaño 3x1 y uno de 1x3, y súmalos utilizando broadcasting para obtener un array de 3x3.
array_6_1 = np.array([[1], [2], [3]])
array_6_2 = np.array([[4, 5, 6]])
suma_broadcasting = array_6_1 + array_6_2
print("Suma con broadcasting:\n", suma_broadcasting)

# 7. De una matriz 5x5, extrae una submatriz 2x2 que comience en la segunda fila y columna.
matriz_7 = np.random.rand(5, 5)
submatriz_7 = matriz_7[1:3, 1:3]
print("Submatriz 7:\n", submatriz_7)

# 8. Crea un array de ceros de tamaño 10 y usa indexado para cambiar el valor de los elementos en el rango de índices 3 a 6 a 5.
array_8 = np.zeros(10)
array_8[3:7] = 5
print("Array 8:", array_8)

# 9. Dada una matriz de 3x3, invierte el orden de sus filas.
matriz_9 = np.random.rand(3, 3)
filas_invertidas = matriz_9[::-1]
print("Matriz 9 con filas invertidas:\n", filas_invertidas)

# 10. Dado un array de números aleatorios de tamaño 10, selecciona y muestra solo aquellos que sean mayores a 0.5.
array_10 = np.random.rand(10)
mayores_a_05 = array_10[array_10 > 0.5]
print("Valores mayores a 0.5:", mayores_a_05)

# Gráficos de dispersión, densidad y contorno
# 11. Genera dos arrays de tamaño 100 con números aleatorios y crea un gráfico de dispersión.
array_11_x = np.random.rand(100)
array_11_y = np.random.rand(100)
plt.scatter(array_11_x, array_11_y)
plt.title("Gráfico de dispersión")
plt.show()

# 12. Genera un gráfico de dispersión las variables 𝑥 y 𝑦 = 𝑠𝑖𝑛(𝑥)+ ruido Gaussiano. Donde x es un array con númereos entre -2𝜋 𝑦 2𝜋. Grafica también los puntos 𝑦 = 𝑠𝑖𝑛(𝑥) en el mismo plot
x = np.linspace(-2*np.pi, 2*np.pi, 100)
ruido = np.random.normal(0, 0.5, 100)
y = np.sin(x) + ruido
plt.scatter(x, y, label='sin(x) + ruido')
plt.plot(x, np.sin(x), color='red', label='sin(x)')
plt.title("Gráfico de dispersión con ruido")
plt.xlabel("Eje X")
plt.ylabel("Eje Y")
plt.legend()
plt.show()

# 13. Utiliza la función np.meshgrid para crear una cuadrícula y luego aplica la función z = np.cos(x) + np.sin(y) para generar y mostrar un gráfico de contorno.
x = np.linspace(-5, 5, 100)
y = np.linspace(-5, 5, 100)
X, Y = np.meshgrid(x, y)
Z = np.cos(X) + np.sin(Y)
plt.contour(X, Y, Z)
plt.title("Gráfico de contorno")
plt.show()

# 14. Crea un gráfico de dispersión con 1000 puntos aleatorios y utiliza la densidad de estos puntos para ajustar el color de cada punto.
x = np.random.rand(1000)
y = np.random.rand(1000)
plt.hist2d(x, y, bins=20, cmap='viridis')
plt.colorbar(label='Densidad')
plt.title("Gráfico de dispersión con densidad")
plt.show()

# 15. A partir de la misma función del ejercicio 12, genera un gráfico de contorno lleno.
x = np.linspace(-2*np.pi, 2*np.pi, 100)
y = np.sin(x)
plt.contourf(x, y)
plt.title("Gráfico de contorno lleno")
plt.show()

# 16. Añade etiquetas para el eje X (‘Eje X’), eje Y (‘Eje Y’) y un título (‘Gráfico de Dispersión’) a tu gráfico de dispersión del ejercicio 12 y crea leyendas para cada gráfico usando código LaTex
x = np.linspace(-2*np.pi, 2*np.pi, 100)
ruido = np.random.normal(0, 0.5, 100)
y = np.sin(x) + ruido
plt.scatter(x, y, label=r'<span class="math-inline">sin\(x\) \+ ruido</span>')
plt.plot(x, np.sin(x), color='red', label=r'<span class="math-inline">sin\(x\)</span>')
plt.title("Gráfico de Dispersión")
plt.xlabel("Eje X")
plt.ylabel("Eje Y")
plt.legend()
plt.show()

# Histogramas
# 16. Crea un histograma a partir de un array de 1000 números aleatorios generados con una distribución normal.
datos_16 = np.random.normal(0, 1, 1000)
plt.hist(datos_16, bins=30)
plt.title("Histograma de distribución normal")
plt.show()

# 17. Genera dos sets de datos con distribuciones normales diferentes y muéstralos en el mismo histograma.
datos_17_1 = np.random.normal(0, 1, 1000)
datos_17_2 = np.random.normal(2, 1.5, 1000)
plt.hist(datos_17_1, bins=30, alpha=0.5, label='Distribución 1')
plt